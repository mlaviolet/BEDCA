---
title: "Chapter 3: Elementary Descriptive Statistics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Chapter 3: Elementary Descriptive Statistics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center"
  )
ggplot2::theme_set(ggplot2::theme_bw())
```

```{r setup}
library(BEDCA)
```

## 3.1: Elementary Graphical and Tabular Treatment of Quantitatve Data

Chapter 3 discusses elementary graphical and numerical summaries: dot diagrams, histograms, run charts, quantiles, mean, standard deviation. Stem-and-leaf plots are omitted from this vignette. We also present a modeling approach to obtaining summary statistics.

### 3.1.1 Dot diagrams

Example 1 (p. 67) of this chapter revisits the heat-treating process for gears introduced in Chapter 1. As noted there, the data for the two gear treatments appear in separate columns, which is not amenable for analysis. Data must be reshaped into tidy format, with one column (`Treatment`) for the treatment type and a second (`Runout`) for the runout measurements.

```{r}
gears <- table1_01 |> 
    tidyr::pivot_longer(cols = everything(), 
                        values_to = "Runout", 
                        names_to = "Treatment") |> 
  # because the sample sizes are unequal one laid gear is shown as missing;
  #   remove it
  dplyr::filter(!is.na(Runout))
```

This code replicates Figure 3.1 (p. 67)

The best way to make a dot diagram is with the `dotPlot` function from the `mosaic` package. The syntax is 

$$\texttt{dotPlot(}\sim \texttt{y | z, data = mydata)}$$

where `y` is the variable to be plotted and `z` is a panel variable; that is, separate plots are produced for each level of `z`. Note the `xlab` argument: always put meaningful labels on your graphs.

```{r}
mosaic::dotPlot(~ Runout | Treatment, data = gears,
                xlab = "Runout (0.0001 in.)")
```

Example 2 discusses a study to compare penetration depths of .45 caliber bullets fired into oak wood. Data appear in Table 3.1 (p. 67) and Section 3.1, Exercise 2 (p. 77). Note that in `table3_01` the 230-grain bullets and the 200-grain bullets are in separate columns. For analysis and graphics we need to reshape the data into "tidy" format. The following code produces a new data set `bullets` with two columns: one (`grain`) for the type of bullet and a second (`depth`) for the depth measurements. This format allows us to group numeric and graphic output by bullet type. After reshaping, we can do a grouped dot diagram.

```{r}
bullets <- table3_01 |> 
      tidyr::pivot_longer(cols = everything(), 
                          names_to = "grain",
                          values_to = "depth")
mosaic::dotPlot(~ depth | grain, data = bullets,
                nint = 12,
                xlab = "Penetration depth (mm)")
```

### 3.1.2 Frequency Tables and Histograms

The following produces the data for Example 1, page 70. Since the measurements for laid gears and hung gears are in separate columns, we need only retain the laid gears with `dplyr::select()`. The `cut()` function divides the range of a quantitative variable into intervals and codes the values according to which interval they fall. The `seq()` function generates the sequence 5, 9, 13, ..., 32 to define the intervals [5,9), [9,13), ..., [25,28). The result of using `cut()`is a factor variable with the intervals as levels.

```{r}
gears_laid <- table1_01 |> 
  # "Laid" and "Hung" are in separate columns; keep "Laid"
  dplyr::select("Laid") |> 
  # drop the row with the "missing" runout
  tidyr::drop_na() |>  
  # divide data into intervals 5-8, 9-12, ..., 25-28
  dplyr::mutate(grp = cut(Laid, 
                          breaks = seq(from = 5, to = 32, by = 4), 
                          right = FALSE))
```

Now we compute the frequencies, relative frequencies, and cumulative relative frequencies from Table 3.2 on page 70:

```{r}
options(digits = 3) # check this out
gears_laid |> 
  dplyr::count(grp, .drop = FALSE) |>  # show intervals with zero count
  dplyr::mutate(rel_freq = n / sum(n), # divide count by number of runouts
         cum_freq = cumsum(rel_freq))  # cumulative relative frequency
```

Table 3.3 (p. 71) is constructed in a similar manner. Try it!

Figure 3.6 (p. 72) is a histogram of penetration depths for the 200-grain bullets. Since we already have the data reshaped, we'll do comparative histograms using both bullet types. The `gf_histogram()` function does the work of dividing the measurements into intervals. Usually the function makes good choices but we can refine the graph by specifying the number of intervals with the `bins` argument.

```{r}
ggformula::gf_histogram(~ depth | grain, data = bullets,
                        bins = 7, # use 7 intervals
                        xlab = "Penetration depth (mm)")
```

### 3.1.3 Scatterplots and Run Charts

Figure 3.9 (p. 75) shows a scatterplot of the torque required to loosen two bolsts (designated Bolt 3 and Bolt 4) on the front plate of a heavy equipment component. The numbers in the plots indicate points falling on the same coordinates.

```{r}
gf_point(bolt4_torque ~ bolt3_torque, data = table3_04,
         xlab = "Bolt 3 torque (ft-lb)", 
         ylab = "Bolt 4 torque (ft-lb)")
```

The numbers in the plot indicate points falling on the same coordinates. To show distinct points we'll add a small amount of "jitter" to the scatterplot. Jittering adds a small amount of random variation to the point location so that all points are visible.

```{r}
gf_jitter(bolt4_torque ~ bolt3_torque, data = table3_04,
          # reduce jitter
          width = 0.2, height = 0.2, 
          xlab = "Bolt 3 torque (ft-lb)", 
          ylab = "Bolt 4 torque (ft-lb)")
```

A run chart is a scatterplot where the horizontal variable represents time. Run charts are usually drawn as points with connecting lines. In the following example (Figure 3.10, p. 76), the aspect ratio is changed to the "golden ratio" for aesthetics.

```{r}
gf_point(diameter ~ joint, data = table3_05) |> 
  gf_line() +                # the + operator adds features to the graph
  theme(aspect.ratio = 0.62) # this type of plot looks better this way
```

## 3.2 Quantiles and Related Graphical Tools

Compute approximate quantiles, p. 79

```{r}
towels <- table3_06 |> 
  dplyr::mutate(i = rank(strength, ties.method = "random"),
                p = (i - 0.5) / length(i)) |> 
  dplyr::arrange(i)
```

Quantile plot, p. 81

```{r}
ggformula::gf_point(strength ~ p, data = towels) |> 
  gf_line() +               
  theme(aspect.ratio = 0.62)
```

Statistics by bullet type

```{r}
mosaic::IQR(depth ~ grain, data = bullets)
mosaic::favstats(depth ~ grain, data = bullets)
```

Boxplot, p. 85

```{r}
ggformula::gf_boxplot(depth ~ grain, data = bullets,
                      xlab = "grain",
                      ylab = "Penetration depth (mm)")
```

Normal plot, p. 90

Add normal quantiles

```{r}
towels <- towels |> 
  mutate(z = qnorm(p))
```

Normal plot

```{r}
ggformula::gf_point(z ~ strength, data = towels)
```

Direct normal plot

```{r}
ggformula::gf_qq(~ strength, data = towels) +
  # flip axes to replicate format in text
  coord_flip()
```

